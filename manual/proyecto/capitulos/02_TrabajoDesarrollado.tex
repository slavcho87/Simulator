\chapter{Trabajo desarrollado}
\thispagestyle{empty}

En este capítulo se explican las funcionalidades básicas del simulador desarrollado centradose únicamente en los aspectos más importantes. Para profundizar más sobre estos aspectos debe acudir a los anexos.

\section{Resumen del simulador}
\thispagestyle{empty}

Se trata de un sistema de colaboración abierta distribuida que permite configurar distintos escenarios con objetos móviles y estáticos sobre mapas de ciudades reales obtenidos a partir del servicio de mapas de OpenStreetMap. 

El simulador de escenarios está basado en el simulador Mavsim desarrollado por el Grupo de Sistemas de Información Distribuidos de la Universidad de Zaragoza utilizado para la simulación de VANETs en el cual hay muchos vehículos distribuidos en una amplia zona geografica.

\begin{figure}[H]
\centering\includegraphics[scale=0.3]{imagenes/resumen-simulador.jpg}
\caption{Simulación en Actur, Zaragoza con un solo usuario}
\label{c2_trama}
\end{figure}

Puede ser usado a través de cualquier dispositovo (PC, tablet, móvil etc.) con conexión a Internet y un navegador web. Permite a los usuarios crear sus propios mapas y escenarios. Durante la creación de una escena el usuario elige cual es la cuidad donde se realiza la simulación, el recomendador a utilizar, si el mapa es colaborativo o no, introducir los objetos estáticos y configurar cuales son los objetos móviles y sus rutas. 

Para realizar una simulación el usuario tiene que buscar y seleccionar el mapa y escenario donde moverse tanto para obtener recomendaciones como para realizar votaciones sobre los distintos objetos de este entorno.

\section{Análisis de requisitos}
\thispagestyle{empty}

\subsection{Requisitos funcionales}
\thispagestyle{empty}

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|l|l|}
\hline
Código de requisito & Descripción \\
\hline \hline
RF-1  & Descripcion \\ \hline
RF-1  & Descripcion \\ \hline
RF-1  & Descripcion \\ \hline
RF-1  & Descripcion \\ \hline
RF-1  & Descripcion \\ \hline
RF-1  & Descripcion \\ \hline
RF-1  & Descripcion \\ \hline
\end{tabular}
\caption{Requisitos funcionales}
\label{tabla:requisitosFuncionales}
\end{center}
\end{table}


\subsection{Requisitos no funcionales}
\thispagestyle{empty}

\begin{table}[htbp]
\begin{center}
\begin{tabular}{|l|l|}
\hline
Código de requisito & Descripción \\
\hline \hline
RNF-1  & Descripcion \\ \hline
RNF-1  & Descripcion \\ \hline
RNF-1  & Descripcion \\ \hline
RNF-1  & Descripcion \\ \hline
RNF-1  & Descripcion \\ \hline
RNF-1  & Descripcion \\ \hline
RNF-1  & Descripcion \\ \hline
\end{tabular}
\caption{Requisitos no funcionales}
\label{tabla:requisitosNoFuncionales}
\end{center}
\end{table}

\section{Arquictura del sistema}
\thispagestyle{empty}

La arquitectura del sistema consta de cliente o navegador web, servidor web Node.js, servidor de recomendaciones y base de datos mongoDB (figura \ref{arquitecturaComponentes}).

El la figura \ref{arquitecturaComponentes} observamos que el navegador web se conecta al servidor Node.js mediante dos maneras: la primera es HTTP y la segunda es un sistema bidireccional dirigido por eventos. Las funcionalidades como creación de escenas, busqueda de mapas etc. están desarrollados sobre una REST API y el intercambio de mensajes JSON.

El sistema bidireccional dirigido por eventos es utilizado por una parte durante la simulación, para reflejar los eventos generados por un usuario al resto de usuarios, y por otra para integrar el navegador, el servidor Node.js y el recomendador. De esta manera conseguimos compartir informácion entre los distintos componentes sin que estos los hayan solicitado evitando muchas peticiones innecesarias.

\begin{figure}[H]
\centering\includegraphics[scale=0.4]{imagenes/arquitectura-componentes.png}
\caption{Arquitectura de componentes del sistema}
\label{arquitecturaComponentes}
\end{figure}

\subsection{Arquitectura del front end}
\thispagestyle{empty}

Para el desarrollo del front end se han utilizado los frameworks Angular.js\footnote{framework que nos permite desarrollar aplicaciones de una sola página} y bootstrap\footnote{framework que nos ofrece un sistema de componentes reutilizables y adaptables a la pantalla del dispositivo}. Se ha decidido utilizar estas tecnologias porque nos ofrece varias ventajas: ahorro de recursos\footnote{angular.js va transmitiendo las vistas de la interfaz gráfica y las cachea al lado del cliente para ser reutilizadas posteriormete. Vuelve a solicitar una vista si y solo si esta ha sufrido algún cambio en el servidor}, mejora de la productividad y la posibilidad de realizar una simulación sobre dispositivos móviles\footnote{esto nos da la oportunidad de utilizar la posición geográfica del usuario para obtener recomendaciones en el entorno de una cuidad real. De está manera obtenemos datos reales y muchas más precisión a la hora de evaluar los algoritmos de recomendaciones} con el mismo código fuente.

La arquitectura del front end está basada en el patrón Modelo-Vista-Controllador de tal forma que para cada vista existe un controlador que contiene la lógica de negocio de esta. El controlador tambien es el encargado de establecer comunicación con el back end. Esta comunicación se realiza mediante los llamados Servicios\footnote{es pequeña fabrica de funciones y objetos inyectada en los controladores} de Angular.js y la REST API del back end. Los Servicios de Angular.js son muy necesarios y útiles ya que nos permiten crear un envoltorio sobre la REST API que nos ofrece el back end y de esta forma centralizar las llamas a la API.

\begin{figure}[H]
\centering\includegraphics[scale=0.6]{imagenes/arquitectura-front-end.png}
\caption{Arquitectura del front end}
\label{arquitecturaFrontEnd}
\end{figure}

\subsection{Arquitectura del back end}
\thispagestyle{empty}

Para el desarrollo del back end se han utilizado Node.js\footnote{javascript al lado del servidor}, Express\footnote{modulo de Node.js que nos ofrece la posiblidad de desarrollar una REST API}, socket.io\footnote{sistema bidireccional dirigido por eventos} y mongoose \footnote{modelado de objetos sobre mongoDB}. Se ha decidido utilizar estas tecnología por que nos ofrecen las siguientes ventajas: mejora la productividad a la hora de desarrollar el back end, nos permite desarrollar un back end ligero que consuma pocos recursos y el modulo sockets.io nos ofrece la posibilidad de desarrollar un sistema bidireccional dirigido por eventos.

La arquitectura del back end se basa en la filosofía de desarrollo de aplicaciones con Node.js y Express y consiste de la siguiente estructura de directorios:

\dirtree{%
.1 Simulator.
.2 app.js.
.2 package.json.
.2 bin.
.3 www.
.2 models.
.2 public.
.3 images.
.3 javascript.
.4 angular.
.4 bootstrap.
.4 jquery.
.4 openlayers.
.4 socketIO.
.3 stylesheets.
.3 views.
.4 configurations.
.4 maps.
.4 settings.
.4 index.html.
.4 register.html.
.3 index.html.
.2 routes.
.3 configuratios.js.
.3 maps.js.
.3 simulation.js.
.3 user.js.
}

\newpage

A continuación vamos a ver más detalladamente cual es la funcion de cada elemento de este directorio:
\begin{itemize}
	\item app.js: centraliza las configuraciones de nuestra aplicación como por ejemplo en que puerto arranca el servidor, establecer conexiones con la base de datos, configuraciones del router\footnote{el router de Node.js es el encargado del direccionamiento de las peticiones y hace referencia a la definición de puntos finales de aplicación (URI) y cómo responden a las solicitudes de cliente} etc.
	\item package.json: es un gestor de paquetes y contiene los modulos que se están utilizando en nuestra aplicación.
	\item public: es un directorio que contiene la parte visual, es decir el front end. Podemos ver que este contiene varios subdirectorios:
	\begin{itemize}
	\item en images se ubican las imagenes o iconos usados en la aplicación.
	\item en javascript se ubican los frameworks Javascript usados en en el front end como Angular.js, Bootstrap, OpenLayers etc. En el subdirectorio angular podemos encontrar las configuraciones de Angular.js, los controladores de las vistas, los Servicios etc.
	\item en views se ubican las vistas del front end.
	\item en stylesheets están ubicadas las hojas de estilos
	\end{itemize}
	\item en routes se ubican las distinas rutas de Express. En nuestro caso tenemos una para cada menú de la aplicación. Por ejemplo todas las operaciones referentes al menú Maps se encuentra en el fichero maps.js etc.
\end{itemize}

\subsection{Arquitectura de recomendador}
\thispagestyle{empty}

El desarrollo del recomendador está realizado con Java 7, la librería Apache Mahout y socket.io-client. El recomendador desarrollado es un recomendador pull\footnote{tipo de recomendador en el cual los usuarios solicitan recomendaciones} de ejemplo basado en los usuarios (User based recommender). 

Aunque sea un recomendador de ejemplo este está pensado para se expandido, tanto para otro tipo de recomendadores (como pueden ser los recomendadores de tipo push\footnote{tipo de recomendador que realiza recomendaciones sin que el usuario los haya solicitado}) como para la implementación de nuevos tipos de estrategias para el recomendador de tipo pull.

Durante el arranque el servidor del recomendador lanza un hilo por cada tipo de recomendador. En nuestro caso solo lanza un hilo que se corresponde al servidor de tipo pull. Este hilo es el que contiene los eventos que invoca el simulador de escenarios. En la figura \ref{diagramaEventos} observamos que tenemos solo dos eventos: uno para recuperar los tipos de implementaciones\footnote{en nuestro caso es User based recommender pero existen otros tipos como Item based recommender} y otro para realizar las recomendaciones.

\begin{figure}[H]
\centering\includegraphics[scale=0.6]{imagenes/diagrama-de-eventos.png}
\caption{Diagrama de eventos}
\label{diagramaEventos}
\end{figure}

El evento recommend es el que se dispara cuando uno de los usuarios solicita una recomendación. Para que se puedan utilizar distintos tipos de implementaciones del recomendador de tipo pull se ha implementado un patrón de diseño de tipo Strategy. Este patrón de diseños nos permite cambiar de estrategia de recomendación en tiempo de ejecución:

\begin{figure}[H]
\includegraphics[scale=0.7]{imagenes/uml.png}
\caption{Diagrama uml del patrón de diseño de tipo Strategy}
\label{diagramaUMLStrategy}
\end{figure}

\section{Menús del simulador de escenarios}
\thispagestyle{empty}

Como en todas las aplicaciones, el simulador de escenarios cuenta con un sistema de menús que dan acceso a las distintas opciones del simulador. En este caso se ha seguido la paradigma WIMP para la organización de los menús y distinas opciones (figura \ref{mapaNavegacion}). Existen 4 tipos de caminos organizados en forma de árbol:

\begin{itemize}
	\item busqueda y gestión (creación, edición y borrados) de mapas y escenas
	\item simulación de un mapa y escena
	\item gestión de tipos de recomendadores, objetos estáticos\footnote{objetos que no cambian de posición a medida que pasa el tiempo} y dinámicos\footnote{objetos que cambian de posición a medida que pasa el tiempo. Tienen una ruta difinida durante la creación de la escena}
	\item configuraciones del perfil del usuario
\end{itemize} 

\begin{figure}[H]
\centering\includegraphics[scale=0.7]{imagenes/mapa-navegacion.png}
\caption{Mapa de navegación}
\label{mapaNavegacion}
\end{figure}

\newpage

\section{Navegación por estima}
\thispagestyle{empty}

La navegación por estima es una técnica que se aplica en el cliente. Consiste en procesar en cada ciclo el estado de los objetos móviles. Se trata de una técnica análitica utilizada en la náutica para la navegación y situación de los barcos y se tienen en cuenta los siguientes elementos: la situación actual, rumbo y velocidad. Es decir, sabiendo la velocidad, el rumbo de la nave y el tiempo transcurido se puede estimar la posición de la misma al cabo del tiempo. 

Con este método conseguimos calcular cual es la siguiente posición geográfica donde tenemos que colocar un objeto móvil al acabo de un tiempo (el tiempo de refresco de la pántalla). Como ventaja conseguimos disminuir el error en el cálculo de las posiciones de los objetos móviles. Así obtenemos movimientos muy precisos incluso en grafos de movimientos con nodos muy cercanos. Para evitar problemas en estos casos se han puesto tiempos bajos de refresco de la pántalla.

\section{Diseño final}
\thispagestyle{empty}
